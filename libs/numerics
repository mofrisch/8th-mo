\ -*- 8th -*-
\ : File: \texttt{numerics} \\
\ : Copyright (c) 2020, Moritz Frisch\\
\ : All rights reserved.\\
\ : This file may be used according to the BSD 3-Clause License\\
\ : see LICENSE for details\\

\ : This is the numerics library, common to all numeric subroutines.

needs tools

ns: nm
\ : Number of iterations maximally performed in an algorithm to avoid
\ : endless loops, if the procedure converges too slowly.
1000 var, max-iterations
\ : By default, we do not show all the steps performed.
false var, num-debug
\ : Width of the exponent display. Your numbers will only look nice,
\ : if your largest exponent is smaller than this.
2 var, exp-size

\ : Width $w$ of the mantissa. We have three places in front, the sign,
\ : a number and the decimal point, so we have $w-3$ decimal places.
var mantissa-size \ n --
\ : Set mantissa size.        
: mantissa! \ n --
    dup mantissa-size ! 3 - ## ;
\ : The default is $\pm1.0000000$.
10 mantissa!

\ : This is the error bound we normally use, the default is $\epsilon=10^{-16}$.
var epsilon
: eps \ -- n
   epsilon @ ;
: eps! \ n --
   epsilon ! ;
1e-16 eps!

\ : In a table, we usually print every line. If you want only every $n$-th line,
\ : set this to $n$. The first and last line will always be shown.
1 var, print-lines 

\ : We use machine numbers by default. If you want big floats, which are 
\ : considerabely slower, you may set e.g. $30$ bigfloats. If you need the
\ : precision, but don't want to display all the places, set \texttt{n\#}
\ : to a convenient value. To avoid problems with rounding or accuracy,
\ : you should use \texttt{big-floats} once and not change it thereafter.
: short-floats \ --
   19 mantissa! 1e-16 eps! ;

: big-floats \ n --
   dup n:1+ dup n# mantissa! F10 swap n:neg n:^ eps! ;

short-floats

\ : Forward declaration of symbols, we often use and like to change.
defer: f
defer: f'

: ld>=1 \ n -- n
   n:1- n:bfloat n:ln1p F9 n:ln1p n:/ ;
\ : Return the decimal $\log$ of $n$. Right now $\ln$ does not work for bfloat, 
\ : so we convert to a float. Of course, we don't have the precision we would
\ : expect. Will be fixed in $20.06$, hopefully. I found ln1p to work, however.
: ld \ n -- n
   dup 1 < if 1 swap n:/ ld>=1 n:neg else ld>=1 then ;

\ : Return the exponent of $n$. For $n > 300$ or so, this is not 
\ : correct because of the $\ln$ error. We could divide successively by $10$ as a
\ : workaround, if the fix is not made soon.
: exponent \ n -- n
   dup 0 > if ld  else
   dup 0 < if n:neg ld else
   then then n:round n:int ;

\ : Return the length of the exponent.
: exp-length \ n -- n
   dup 0 n:<> if n:abs ld n:int n:1+ else drop 1 then ; 
   

\ : Print the sign of the exponent.
: print-sign \ n -- n
   dup 0 < if "-" . else "+" . then ;

\ : Print zeroes to fill the exponent.
: print-zeroes \ n -- n
   dup exp-length exp-size @ swap n:- ( "0" . ) swap times ;

\ : Print the value of the exponent.   
: print-value \ n --
   n:abs . ;

\ : Print the exponent as $\pm01$.
: print-exponent \ n -- +|-00n
   print-sign print-zeroes print-value ;

\ : Return the mantissa.
: mantissa \ n exp -- n
   10. swap n:^ n:/ ; 

\ : Print a number in the format $[-]1.0000000e\pm01$.
: f. \ n --
   mantissa-size @ #>
   dup exponent dup  >r \ n exp
   mantissa . "e" . 
   r> print-exponent ;

: num-size
   mantissa-size @ exp-size @ 2 n:+ n:+ ;

[] var, messages
[] var, row
0 var, row-length

: print-header \ a --
   "n    " .
   dup ( dup . s:len num-size swap n:- n:1+ ( space ) swap times drop ) a:each! cr
   a:len num-size n:1+ * 3 n:+ 
   dup row-length !
   draw-line cr 2drop ;

: print-row \ n x1 -- n x1
   num-debug @ if
      dup dup print-lines @ n:mod 0 = if
         4 #> .
         row @ ( f. space ) a:each! drop
         cr 
      then 
   then ;
   

: print-footer
   row-length @ draw-line cr ;

: print-messages
   messages @ ( . ) a:each! drop ;

: nearly-zero \ n -- T
   0 eps n:~ ;

: max-iters? \ n  -- T
   max-iterations @ n:= dup if 
      messages @ "too many iterations" a:push drop 
   then ;

defer: criterion?
defer: algorithm

: finished \ n x1 -- x1
   criterion? swap max-iters? or if break then ;

: add-item \ val ix -- val
   over row @ -rot a:! drop ;

: do-it \ i x0 -- x1
   algorithm print-row finished ;


   

